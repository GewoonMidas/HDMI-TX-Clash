/* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
** GENERATED BY CLASH 1.6.3. DO NOT MODIFY.
*/
`timescale 100fs/100fs
module I2CTest_system_system0
    ( // Inputs
      input  clk // clock
    , input  arst // reset

      // Outputs
    , output wire [793:0] result
    );
  wire  result_0;
  // I2CTest.hs:12:1-7
  wire [0:0] c$scl_app_arg;
  // I2CTest.hs:12:1-7
  wire [0:0] c$ds2_app_arg;
  wire [4:0] i1;
  wire [12:0] result_1;
  wire [15:0] c$case_alt;
  wire [15:0] result_2;
  // Hdmi/Init.hs:52:1-11
  reg [18:0] state = {3'd0,   1'b0,   1'b0,   1'b0,   {1'b0,   1'b0,   1'b0,   1'b0,   1'b0,   1'b0,
                                  1'b0,   1'b0},   4'd0,   1'b0};
  wire [18:0] c$ds_case_alt;
  // Hdmi/Init.hs:52:1-11
  wire  rst;
  reg [18:0] result_3;
  wire [18:0] c$ds_case_alt_0;
  wire [18:0] c$ds_case_alt_1;
  wire [18:0] c$ds_case_alt_2;
  wire [18:0] c$ds_case_alt_3;
  wire [18:0] c$ds_case_alt_4;
  // Hdmi/Init.hs:52:1-11
  wire  rxAck;
  wire [18:0] c$ds_case_alt_5;
  wire  c$ds_case_scrut;
  // Hdmi/Init.hs:52:1-11
  wire  cmdAck;
  // Hdmi/Init.hs:52:1-11
  wire  al;
  wire [18:0] c$ds_case_alt_6;
  // Hdmi/Init.hs:52:1-11
  wire  ena;
  // Hdmi/Init.hs:52:1-11
  wire  done;
  // I2CTest.hs:12:1-7
  wire  scl;
  // I2CTest.hs:12:1-7
  wire [792:0] ds2;
  // I2CTest.hs:12:1-7
  wire [15:0] ds3;
  // I2CTest.hs:12:1-7
  reg [17:0] rstCounter = 18'd0;
  wire [3:0] c$i_20;
  wire [127:0] c$vecFlat;
  wire [2:0] result_selection_4;
  wire [7:0] result_sel_alt_res;
  wire [7:0] c$vec;
  wire  arg_0;
  wire [1:0] arg;
  wire  arg_1;
  wire  arg_2;
  wire [792:0] result_5;
  wire  clk_0;
  wire  arst_0;
  wire  rst_1;
  wire  ena_1;
  wire [15:0] clkCnt_0;
  wire  start_0;
  wire  stop_0;
  wire  read_0;
  wire  write_0;
  wire  ackIn_0;
  wire [7:0] din_0;
  wire [1:0] i2cI_0;
  wire [15:0] result_6;
  wire [7:0] dout_0;
  wire  hostAck_0;
  wire  busy_0;
  wire  al_1;
  wire  ackOut_0;
  wire [3:0] result_5_13;
  wire  i2cO_clk_0;
  wire  result_5_14;
  wire  result_5_15;
  wire  result_5_16;

  assign result_0 = rstCounter < 18'd500;

  assign c$scl_app_arg = ds3[2:2] ? 1'b1 : 1'b0;

  assign c$ds2_app_arg = ds3[0:0] ? 1'b1 : 1'b0;

  assign result = {ds2[791:0],   result_1[1:1],
                   result_1[0:0]};

  assign i1 = {result_0,   ~ result_0,
               ds3[7:7],   ds3[4:4],   ds3[5:5]};

  assign result_1 = {state[15:15],
                     state[14:14],   state[13:13],
                     ((state[12:5])),   done,   state[0:0]};

  assign c$i_20 = state[4:1];

  assign c$vecFlat = {{8'b00000000,
                       8'b00010000},   {8'b00001000,   8'b00000000},
                      {8'b00001000,   8'b00010000},   {8'b11000010,
                                                       8'b00010000},   {8'b00001000,   8'b00000000},
                      {8'b00001000,   8'b00000100},   {8'b00001000,
                                                       8'b00000000},   {8'b11000010,   8'b00000000}};

  // index begin
  wire [15:0] vecArray [0:8-1];
  genvar i;
  generate
  for (i=0; i < 8; i=i+1) begin : mk_array
    assign vecArray[(8-1)-i] = c$vecFlat[i*16+:16];
  end
  endgenerate
  assign c$case_alt = vecArray[($unsigned({{(64-4) {1'b0}},c$i_20}))];
  // index end

  assign result_2 = (state[4:1] > 4'd8) ? {8'b00000100,
                                           8'b00000000} : c$case_alt;

  // register begin
  always @(posedge clk or  posedge  arst) begin : state_register
    if ( arst) begin
      state <= {3'd0,   1'b0,   1'b0,   1'b0,   {1'b0,   1'b0,   1'b0,   1'b0,   1'b0,   1'b0,
                                    1'b0,   1'b0},   4'd0,   1'b0};
    end else begin
      state <= c$ds_case_alt;
    end
  end
  // register end

  assign c$ds_case_alt = rst ? {3'd0,   1'b0,
                                1'b0,   1'b0,   {8 {(1'b0)}},   4'd0,
                                1'b0} : result_3;

  assign rst = i1[4:4];

  assign result_selection_4 = state[18:16];

  assign c$vec = (8'b10011000);

  // map begin
  genvar i_0;
  generate
  for (i_0=0; i_0 < 8; i_0 = i_0 + 1) begin : map
    wire [0:0] map_in;
    assign map_in = c$vec[i_0*1+:1];
    wire  map_out;
    assign map_out = map_in;


    assign result_sel_alt_res[i_0*1+:1] = map_out;
  end
  endgenerate
  // map end

  always @(*) begin
    case(result_selection_4)
      3'b000 : result_3 = c$ds_case_alt_6;
      3'b001 : result_3 = {3'd2,   1'b1,
                           state[14:14],   1'b1,   result_sel_alt_res,
                           state[4:1],   state[0:0]};
      3'b010 : result_3 = c$ds_case_alt_5;
      3'b011 : result_3 = c$ds_case_alt_4;
      3'b100 : result_3 = c$ds_case_alt_3;
      3'b101 : result_3 = c$ds_case_alt_2;
      3'b110 : result_3 = c$ds_case_alt_1;
      default : result_3 = c$ds_case_alt_0;
    endcase
  end

  assign c$ds_case_alt_0 = rxAck ? {3'd0,
                                    state[15:15],   state[14:14],   state[13:13],
                                    state[12:5],   state[4:1],   1'b1} : {3'd0,
                                                                          state[15:15],   state[14:14],   state[13:13],
                                                                          state[12:5],   state[4:1] + 4'd1,   1'b0};

  assign c$ds_case_alt_1 = c$ds_case_scrut ? {3'd7,
                                              state[15:15],   1'b0,   1'b0,   state[12:5],
                                              state[4:1],   state[0:0]} : state;

  assign c$ds_case_alt_2 = rxAck ? {3'd0,
                                    state[15:15],   state[14:14],   state[13:13],
                                    state[12:5],   state[4:1],   1'b1} : {3'd6,
                                                                          state[15:15],   1'b1,   1'b1,
                                                                          (result_2[7:0]),   state[4:1],   1'b0};

  assign c$ds_case_alt_3 = c$ds_case_scrut ? {3'd5,
                                              state[15:15],   state[14:14],   1'b0,
                                              state[12:5],   state[4:1],
                                              state[0:0]} : state;

  assign c$ds_case_alt_4 = rxAck ? {3'd0,
                                    state[15:15],   state[14:14],   state[13:13],
                                    state[12:5],   state[4:1],   1'b1} : {3'd4,
                                                                          state[15:15],   state[14:14],   1'b1,
                                                                          (result_2[15:8]),   state[4:1],   1'b0};

  assign rxAck = i1[1:1];

  assign c$ds_case_alt_5 = c$ds_case_scrut ? {3'd3,
                                              1'b0,   state[14:14],   1'b0,   state[12:5],
                                              state[4:1],   state[0:0]} : state;

  assign c$ds_case_scrut = cmdAck & (~ al);

  assign cmdAck = i1[2:2];

  assign al = i1[0:0];

  assign c$ds_case_alt_6 = (ena & (~ done)) ? {3'd1,
                                               state[15:15],   state[14:14],   state[13:13],
                                               state[12:5],   state[4:1],
                                               state[0:0]} : state;

  assign ena = i1[3:3];

  assign done = state[4:1] == 4'd8;

  assign scl = (c$scl_app_arg);

  assign arg_0 = clk;

  assign arg = {scl,   (c$ds2_app_arg)};

  assign arg_1 = arg[1:1];

  assign arg_2 = arg[0:0];

  slave slave_ds2
    (arg_0, arg_1, arg_2, result_5);

  assign ds2 = result_5;

  assign clk_0 = clk;

  assign arst_0 = arst;

  assign rst_1 = result_0;

  assign ena_1 = 1'b1;

  assign clkCnt_0 = 16'd19;

  assign start_0 = result_1[12:12];

  assign stop_0 = result_1[11:11];

  assign read_0 = 1'b0;

  assign write_0 = result_1[10:10];

  assign ackIn_0 = 1'b1;

  assign din_0 = result_1[9:2];

  assign i2cI_0 = {scl,   ds2[792:792]};

  i2c i2c_ds3
    ( clk_0
    , arst_0
    , rst_1
    , ena_1
    , clkCnt_0
    , start_0
    , stop_0
    , read_0
    , write_0
    , ackIn_0
    , din_0
    , i2cI_0
    , dout_0
    , hostAck_0
    , busy_0
    , al_1
    , ackOut_0
    , i2cO_clk_0
    , result_5_14
    , result_5_15
    , result_5_16 );

  assign result_6 = {dout_0,   hostAck_0,
                     busy_0,   al_1,   ackOut_0,   result_5_13};

  assign result_5_13 = {i2cO_clk_0,
                        result_5_14,   result_5_15,   result_5_16};

  assign ds3 = result_6;

  // register begin
  always @(posedge clk or  posedge  arst) begin : rstCounter_register
    if ( arst) begin
      rstCounter <= 18'd0;
    end else begin
      rstCounter <= (rstCounter + 18'd1);
    end
  end
  // register end


endmodule

